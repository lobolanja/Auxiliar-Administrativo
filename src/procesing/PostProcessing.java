/**
 * @author : Juan Carlos Chaves Puertas
 * @version : 1.0
 * @copyright : Copyright (C) 2017
 * @license : MIT (expat) License
 * @maintainer : Juan Carlos Chaves Puertas
 * @email : lobolanja@gmail.com
 */
package procesing;

import javax.swing.JOptionPane;
import database.DBHandler;
import entities.InformResult;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.InputStream;
import java.io.PrintStream;
import java.io.PrintWriter;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.Scanner;
import org.apache.commons.net.ftp.*;

public class PostProcessing {
    private DBHandler dbHandler = new DBHandler();
    private String css_route = "style.css";
    private String html_route;

    public PostProcessing() {
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyyMMdd");
        Date date = new Date();
        this.html_route ="Notas_auxiliar_administrativo.html";
        
    }

    /*
     * WARNING - Removed try catching itself - possible behaviour change.
     */
    public int doInform() throws FileNotFoundException {
        int n = 0;
        String new_line=" ";
        this.dbHandler.connect();
        try {
            PrintWriter printWriter = new PrintWriter(this.html_route, "UTF-8");
            File fichero = new File("plantilla.txt");
            Scanner datosFichero = new Scanner(fichero);
            while (datosFichero.hasNext() && !"</head>".equals(new_line) ){ 
                printWriter.println(new_line);
                new_line=datosFichero.nextLine();
            }
            printWriter.println("<meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8\" />");
            printWriter.println("<script src=\"http://ajax.googleapis.com/ajax/libs/jquery/2.1.0/jquery.min.js\"></script>");
            printWriter.println("<script>");
            this.printTableSorter(printWriter);
            printWriter.println("</script>");
            printWriter.println("<style type=\"text/css\">\ntable {border-collapse: collapse;\nborder: 1px solid #000;\nfont: normal 80%/140% arial, helvetica, sans-serif;\ncolor: #555;\nbackground: #fff;}\n\ntd, th {border: 1px dotted #bbb;\npadding: .5em;}\n\ncaption {padding: 0 0 .5em 0;\ntext-align: left;\nfont-size: 1.4em;\nfont-weight: bold;\ntext-transform: uppercase;\ncolor: #333;\nbackground: transparent;}\n\nthead th, tfoot th {border: 2px solid #000;\ntext-align: left;\nfont-size: 1.2em;\nfont-weight: bold;\ncolor: #333;\nbackground: transparent;}\n\ntbody th, tbody td {vertical-align: top;\ntext-align: left;}\n\ntbody th {white-space: nowrap;}\n\n.odd {background: #fcfcfc;}\n\ntbody tr:hover {background: #E3B14A;}\n\ntfoot td {border: 2px solid #000;}\n\n.recent {\n\tbackground-color:#CAD9E8;\n}  </style>");
            printWriter.println("<script>\n$(document).ready(function() \n    { \n        $(\"#results\").tablesorter(); \n    } \n);\n</script>");
            printWriter.println("</head>");
            while (datosFichero.hasNext() && !"<!-- /Header -->".equals(new_line) ){ 
                printWriter.println(new_line);
                new_line=datosFichero.nextLine();
            }
             printWriter.println("<a href=\"javascript:window.history.back();\"><img src=\"http://i97.servimg.com/u/f97/19/21/91/00/logo_s13.jpg\" width=\"200\" height=\"135\" border=\"0\"></a>");
            printWriter.println("<h2>Notas de corte del \u00faltimo candidato contratado</h2>");
            printWriter.println("<p>Actualizado a " + this.dbHandler.getDateLastConsult() + ".</p>");
            printWriter.println("<table id=\"results\" class=\"tablesorter\"><thead>");
            printWriter.println("<tr>");
            printWriter.println("<th rowspan='2'>Centro</th> <th rowspan='2'>Categor\u00eda</th> <th rowspan='2'>Tipo de vinculaci\u00f3n</th> <th rowspan='2'>Sistema de acceso</th> <th rowspan='2'>Nombramientos \u00faltimo a\u00f1o</th> <td colspan='2'>\u00daltimo contrato</td>");
            printWriter.println("</tr>");
            printWriter.println("<tr>");
            printWriter.println("<th>Nota</th> <th>Fecha</th>");
            printWriter.println("</tr></thead><tbody>");
            ArrayList<InformResult> arrayList = this.dbHandler.getInformResults();
            System.out.println("\nTamanio de resultados para html: " + arrayList.size() + "\n");
            if (arrayList != null) {
                for (InformResult informResult : arrayList) {
                    if (informResult.isRecent()) {
                        printWriter.println("<tr class=\"recent\">");
                    } else {
                        printWriter.println("<tr>");
                    }
                    printWriter.println("<td>" + informResult.getCentro() + "</td>");
                    printWriter.println("<td>" + "Auxiliar Administrativo" + "</td>");
                    printWriter.println("<td>" + informResult.getTipo_vinculacion() + "</td>");
                    printWriter.println("<td>" + informResult.getSistema_acceso() + "</td>");
                    if (informResult.getNomb_anyo() == 0) {
                        printWriter.println("<td>Sin info.</td>");
                    } else {
                        printWriter.println("<td>" + informResult.getNomb_anyo() + "</td>");
                    }
                    double d = (double)informResult.getUlt_contr_nota() / (double)informResult.getFactor();
                    printWriter.println("<td>" + d + "</td>");
                    printWriter.println("<td>" + informResult.getUlt_contr_fecha() + "</td>");
                    printWriter.println("</tr>");
                    ++n;
                }
            } else {
                n = 0;
            }
            printWriter.println("</tbody></table>");
           
            while (datosFichero.hasNext()){ 
                printWriter.println(new_line);
                new_line=datosFichero.nextLine();
            }
            printWriter.close();
            System.out.println("Finished html");
        }
        catch (Exception var2_3) {
            System.out.println(var2_3.toString());
        }
        finally {
            this.dbHandler.disconnect();
        }
        System.out.println("vamos a subirlo");
        if(true == ftpTransfer("./Notas_auxiliar_administrativo.html", "/web/Contrataciones/notas_auxiliar_administrativo.html")){
            System.out.println("se ha subido");
            JOptionPane.showMessageDialog(null, "Se ha subido el archivo al servidor.");
        }
        return n;
    }

    private void printTableSorter(PrintWriter printWriter) {
        printWriter.println("/*\n * \n * TableSorter 2.0 - Client-side table sorting with ease!\n * Version 2.0.5b\n * @requires jQuery v1.2.3\n * \n * Copyright (c) 2007 Christian Bach\n * Examples and docs at: http://tablesorter.com\n * Dual licensed under the MIT and GPL licenses:\n * http://www.opensource.org/licenses/mit-license.php\n * http://www.gnu.org/licenses/gpl.html\n * \n */\n/**\n * \n * @description Create a sortable table with multi-column sorting capabilitys\n * \n * @example $('table').tablesorter();\n * @desc Create a simple tablesorter interface.\n * \n * @example $('table').tablesorter({ sortList:[[0,0],[1,0]] });\n * @desc Create a tablesorter interface and sort on the first and secound column column headers.\n * \n * @example $('table').tablesorter({ headers: { 0: { sorter: false}, 1: {sorter: false} } });\n *          \n * @desc Create a tablesorter interface and disableing the first and second  column headers.\n *      \n * \n * @example $('table').tablesorter({ headers: { 0: {sorter:\"integer\"}, 1: {sorter:\"currency\"} } });\n * \n * @desc Create a tablesorter interface and set a column parser for the first\n *       and second column.\n * \n * \n * @param Object\n *            settings An object literal containing key/value pairs to provide\n *            optional settings.\n * \n * \n * @option String cssHeader (optional) A string of the class name to be appended\n *         to sortable tr elements in the thead of the table. Default value:\n *         \"header\"\n * \n * @option String cssAsc (optional) A string of the class name to be appended to\n *         sortable tr elements in the thead on a ascending sort. Default value:\n *         \"headerSortUp\"\n * \n * @option String cssDesc (optional) A string of the class name to be appended\n *         to sortable tr elements in the thead on a descending sort. Default\n *         value: \"headerSortDown\"\n * \n * @option String sortInitialOrder (optional) A string of the inital sorting\n *         order can be asc or desc. Default value: \"asc\"\n * \n * @option String sortMultisortKey (optional) A string of the multi-column sort\n *         key. Default value: \"shiftKey\"\n * \n * @option String textExtraction (optional) A string of the text-extraction\n *         method to use. For complex html structures inside td cell set this\n *         option to \"complex\", on large tables the complex option can be slow.\n *         Default value: \"simple\"\n * \n * @option Object headers (optional) An array containing the forces sorting\n *         rules. This option let's you specify a default sorting rule. Default\n *         value: null\n * \n * @option Array sortList (optional) An array containing the forces sorting\n *         rules. This option let's you specify a default sorting rule. Default\n *         value: null\n * \n * @option Array sortForce (optional) An array containing forced sorting rules.\n *         This option let's you specify a default sorting rule, which is\n *         prepended to user-selected rules. Default value: null\n * \n * @option Boolean sortLocaleCompare (optional) Boolean flag indicating whatever\n *         to use String.localeCampare method or not. Default set to true.\n * \n * \n * @option Array sortAppend (optional) An array containing forced sorting rules.\n *         This option let's you specify a default sorting rule, which is\n *         appended to user-selected rules. Default value: null\n * \n * @option Boolean widthFixed (optional) Boolean flag indicating if tablesorter\n *         should apply fixed widths to the table columns. This is usefull when\n *         using the pager companion plugin. This options requires the dimension\n *         jquery plugin. Default value: false\n * \n * @option Boolean cancelSelection (optional) Boolean flag indicating if\n *         tablesorter should cancel selection of the table headers text.\n *         Default value: true\n * \n * @option Boolean debug (optional) Boolean flag indicating if tablesorter\n *         should display debuging information usefull for development.\n * \n * @type jQuery\n * \n * @name tablesorter\n * \n * @cat Plugins/Tablesorter\n * \n * @author Christian Bach/christian.bach@polyester.se\n */\n\n(function ($) {\n    $.extend({\n        tablesorter: new\n        function () {\n\n            var parsers = [],\n                widgets = [];\n\n            this.defaults = {\n                cssHeader: \"header\",\n                cssAsc: \"headerSortUp\",\n                cssDesc: \"headerSortDown\",\n                cssChildRow: \"expand-child\",\n                sortInitialOrder: \"asc\",\n                sortMultiSortKey: \"shiftKey\",\n                sortForce: null,\n                sortAppend: null,\n                sortLocaleCompare: true,\n                textExtraction: \"simple\",\n                parsers: {}, widgets: [],\n                widgetZebra: {\n                    css: [\"even\", \"odd\"]\n                }, headers: {}, widthFixed: false,\n                cancelSelection: true,\n                sortList: [],\n                headerList: [],\n                dateFormat: \"us\",\n                decimal: '/\\.|\\,/g',\n                onRenderHeader: null,\n                selectorHeaders: 'thead th',\n                debug: false\n            };\n\n            /* debuging utils */\n\n            function benchmark(s, d) {\n                log(s + \",\" + (new Date().getTime() - d.getTime()) + \"ms\");\n            }\n\n            this.benchmark = benchmark;\n\n            function log(s) {\n                if (typeof console != \"undefined\" && typeof console.debug != \"undefined\") {\n                    console.log(s);\n                } else {\n                    alert(s);\n                }\n            }\n\n            /* parsers utils */\n\n            function buildParserCache(table, $headers) {\n\n                if (table.config.debug) {\n                    var parsersDebug = \"\";\n                }\n\n                if (table.tBodies.length == 0) return; // In the case of empty tables\n                var rows = table.tBodies[0].rows;\n\n                if (rows[0]) {\n\n                    var list = [],\n                        cells = rows[0].cells,\n                        l = cells.length;\n\n                    for (var i = 0; i < l; i++) {\n\n                        var p = false;\n\n                        if ($.metadata && ($($headers[i]).metadata() && $($headers[i]).metadata().sorter)) {\n\n                            p = getParserById($($headers[i]).metadata().sorter);\n\n                        } else if ((table.config.headers[i] && table.config.headers[i].sorter)) {\n\n                            p = getParserById(table.config.headers[i].sorter);\n                        }\n                        if (!p) {\n\n                            p = detectParserForColumn(table, rows, -1, i);\n                        }\n\n                        if (table.config.debug) {\n                            parsersDebug += \"column:\" + i + \" parser:\" + p.id + \"\\n\";\n                        }\n\n                        list.push(p);\n                    }\n                }\n\n                if (table.config.debug) {\n                    log(parsersDebug);\n                }\n\n                return list;\n            };\n\n            function detectParserForColumn(table, rows, rowIndex, cellIndex) {\n                var l = parsers.length,\n                    node = false,\n                    nodeValue = false,\n                    keepLooking = true;\n                while (nodeValue == '' && keepLooking) {\n                    rowIndex++;\n                    if (rows[rowIndex]) {\n                        node = getNodeFromRowAndCellIndex(rows, rowIndex, cellIndex);\n                        nodeValue = trimAndGetNodeText(table.config, node);\n                        if (table.config.debug) {\n                            log('Checking if value was empty on row:' + rowIndex);\n                        }\n                    } else {\n                        keepLooking = false;\n                    }\n                }\n                for (var i = 1; i < l; i++) {\n                    if (parsers[i].is(nodeValue, table, node)) {\n                        return parsers[i];\n                    }\n                }\n                // 0 is always the generic parser (text)\n                return parsers[0];\n            }\n\n            function getNodeFromRowAndCellIndex(rows, rowIndex, cellIndex) {\n                return rows[rowIndex].cells[cellIndex];\n            }\n\n            function trimAndGetNodeText(config, node) {\n                return $.trim(getElementText(config, node));\n            }\n\n            function getParserById(name) {\n                var l = parsers.length;\n                for (var i = 0; i < l; i++) {\n                    if (parsers[i].id.toLowerCase() == name.toLowerCase()) {\n                        return parsers[i];\n                    }\n                }\n                return false;\n            }\n\n            /* utils */\n\n            function buildCache(table) {\n\n                if (table.config.debug) {\n                    var cacheTime = new Date();\n                }\n\n                var totalRows = (table.tBodies[0] && table.tBodies[0].rows.length) || 0,\n                    totalCells = (table.tBodies[0].rows[0] && table.tBodies[0].rows[0].cells.length) || 0,\n                    parsers = table.config.parsers,\n                    cache = {\n                        row: [],\n                        normalized: []\n                    };\n\n                for (var i = 0; i < totalRows; ++i) {\n\n                    /** Add the table data to main data array */\n                    var c = $(table.tBodies[0].rows[i]),\n                        cols = [];\n\n                    // if this is a child row, add it to the last row's children and\n                    // continue to the next row\n                    if (c.hasClass(table.config.cssChildRow)) {\n                        cache.row[cache.row.length - 1] = cache.row[cache.row.length - 1].add(c);\n                        // go to the next for loop\n                        continue;\n                    }\n\n                    cache.row.push(c);\n\n                    for (var j = 0; j < totalCells; ++j) {\n                        cols.push(parsers[j].format(getElementText(table.config, c[0].cells[j]), table, c[0].cells[j]));\n                    }\n\n                    cols.push(cache.normalized.length); // add position for rowCache\n                    cache.normalized.push(cols);\n                    cols = null;\n                };\n\n                if (table.config.debug) {\n                    benchmark(\"Building cache for \" + totalRows + \" rows:\", cacheTime);\n                }\n\n                return cache;\n            };\n\n            function getElementText(config, node) {\n\n                var text = \"\";\n\n                if (!node) return \"\";\n\n                if (!config.supportsTextContent) config.supportsTextContent = node.textContent || false;\n\n                if (config.textExtraction == \"simple\") {\n                    if (config.supportsTextContent) {\n                        text = node.textContent;\n                    } else {\n                        if (node.childNodes[0] && node.childNodes[0].hasChildNodes()) {\n                            text = node.childNodes[0].innerHTML;\n                        } else {\n                            text = node.innerHTML;\n                        }\n                    }\n                } else {\n                    if (typeof(config.textExtraction) == \"function\") {\n                        text = config.textExtraction(node);\n                    } else {\n                        text = $(node).text();\n                    }\n                }\n                return text;\n            }\n\n            function appendToTable(table, cache) {\n\n                if (table.config.debug) {\n                    var appendTime = new Date()\n                }\n\n                var c = cache,\n                    r = c.row,\n                    n = c.normalized,\n                    totalRows = n.length,\n                    checkCell = (n[0].length - 1),\n                    tableBody = $(table.tBodies[0]),\n                    rows = [];\n\n\n                for (var i = 0; i < totalRows; i++) {\n                    var pos = n[i][checkCell];\n\n                    rows.push(r[pos]);\n\n                    if (!table.config.appender) {\n\n                        //var o = ;\n                        var l = r[pos].length;\n                        for (var j = 0; j < l; j++) {\n                            tableBody[0].appendChild(r[pos][j]);\n                        }\n\n                        // \n                    }\n                }\n\n\n\n                if (table.config.appender) {\n\n                    table.config.appender(table, rows);\n                }\n\n                rows = null;\n\n                if (table.config.debug) {\n                    benchmark(\"Rebuilt table:\", appendTime);\n                }\n\n                // apply table widgets\n                applyWidget(table);\n\n                // trigger sortend\n                setTimeout(function () {\n                    $(table).trigger(\"sortEnd\");\n                }, 0);\n\n            };\n\n            function buildHeaders(table) {\n\n                if (table.config.debug) {\n                    var time = new Date();\n                }\n\n                var meta = ($.metadata) ? true : false;\n                \n                var header_index = computeTableHeaderCellIndexes(table);\n\n                $tableHeaders = $(table.config.selectorHeaders, table).each(function (index) {\n\n                    this.column = header_index[this.parentNode.rowIndex + \"-\" + this.cellIndex];\n                    // this.column = index;\n                    this.order = formatSortingOrder(table.config.sortInitialOrder);\n                    \n\t\t\t\t\t\n\t\t\t\t\tthis.count = this.order;\n\n                    if (checkHeaderMetadata(this) || checkHeaderOptions(table, index)) this.sortDisabled = true;\n\t\t\t\t\tif (checkHeaderOptionsSortingLocked(table, index)) this.order = this.lockedOrder = checkHeaderOptionsSortingLocked(table, index);\n\n                    if (!this.sortDisabled) {\n                        var $th = $(this).addClass(table.config.cssHeader);\n                        if (table.config.onRenderHeader) table.config.onRenderHeader.apply($th);\n                    }\n\n                    // add cell to headerList\n                    table.config.headerList[index] = this;\n                });\n\n                if (table.config.debug) {\n                    benchmark(\"Built headers:\", time);\n                    log($tableHeaders);\n                }\n\n                return $tableHeaders;\n\n            };\n\n            // from:\n            // http://www.javascripttoolbox.com/lib/table/examples.php\n            // http://www.javascripttoolbox.com/temp/table_cellindex.html\n\n\n            function computeTableHeaderCellIndexes(t) {\n                var matrix = [];\n                var lookup = {};\n                var thead = t.getElementsByTagName('THEAD')[0];\n                var trs = thead.getElementsByTagName('TR');\n\n                for (var i = 0; i < trs.length; i++) {\n                    var cells = trs[i].cells;\n                    for (var j = 0; j < cells.length; j++) {\n                        var c = cells[j];\n\n                        var rowIndex = c.parentNode.rowIndex;\n                        var cellId = rowIndex + \"-\" + c.cellIndex;\n                        var rowSpan = c.rowSpan || 1;\n                        var colSpan = c.colSpan || 1\n                        var firstAvailCol;\n                        if (typeof(matrix[rowIndex]) == \"undefined\") {\n                            matrix[rowIndex] = [];\n                        }\n                        // Find first available column in the first row\n                        for (var k = 0; k < matrix[rowIndex].length + 1; k++) {\n                            if (typeof(matrix[rowIndex][k]) == \"undefined\") {\n                                firstAvailCol = k;\n                                break;\n                            }\n                        }\n                        lookup[cellId] = firstAvailCol;\n                        for (var k = rowIndex; k < rowIndex + rowSpan; k++) {\n                            if (typeof(matrix[k]) == \"undefined\") {\n                                matrix[k] = [];\n                            }\n                            var matrixrow = matrix[k];\n                            for (var l = firstAvailCol; l < firstAvailCol + colSpan; l++) {\n                                matrixrow[l] = \"x\";\n                            }\n                        }\n                    }\n                }\n                return lookup;\n            }\n\n            function checkCellColSpan(table, rows, row) {\n                var arr = [],\n                    r = table.tHead.rows,\n                    c = r[row].cells;\n\n                for (var i = 0; i < c.length; i++) {\n                    var cell = c[i];\n\n                    if (cell.colSpan > 1) {\n                        arr = arr.concat(checkCellColSpan(table, headerArr, row++));\n                    } else {\n                        if (table.tHead.length == 1 || (cell.rowSpan > 1 || !r[row + 1])) {\n                            arr.push(cell);\n                        }\n                        // headerArr[row] = (i+row);\n                    }\n                }\n                return arr;\n            };\n\n            function checkHeaderMetadata(cell) {\n                if (($.metadata) && ($(cell).metadata().sorter === false)) {\n                    return true;\n                };\n                return false;\n            }\n\n            function checkHeaderOptions(table, i) {\n                if ((table.config.headers[i]) && (table.config.headers[i].sorter === false)) {\n                    return true;\n                };\n                return false;\n            }\n\t\t\t\n\t\t\t function checkHeaderOptionsSortingLocked(table, i) {\n                if ((table.config.headers[i]) && (table.config.headers[i].lockedOrder)) return table.config.headers[i].lockedOrder;\n                return false;\n            }\n\t\t\t\n            function applyWidget(table) {\n                var c = table.config.widgets;\n                var l = c.length;\n                for (var i = 0; i < l; i++) {\n\n                    getWidgetById(c[i]).format(table);\n                }\n\n            }\n\n            function getWidgetById(name) {\n                var l = widgets.length;\n                for (var i = 0; i < l; i++) {\n                    if (widgets[i].id.toLowerCase() == name.toLowerCase()) {\n                        return widgets[i];\n                    }\n                }\n            };\n\n            function formatSortingOrder(v) {\n                if (typeof(v) != \"Number\") {\n                    return (v.toLowerCase() == \"desc\") ? 1 : 0;\n                } else {\n                    return (v == 1) ? 1 : 0;\n                }\n            }\n\n            function isValueInArray(v, a) {\n                var l = a.length;\n                for (var i = 0; i < l; i++) {\n                    if (a[i][0] == v) {\n                        return true;\n                    }\n                }\n                return false;\n            }\n\n            function setHeadersCss(table, $headers, list, css) {\n                // remove all header information\n                $headers.removeClass(css[0]).removeClass(css[1]);\n\n                var h = [];\n                $headers.each(function (offset) {\n                    if (!this.sortDisabled) {\n                        h[this.column] = $(this);\n                    }\n                });\n\n                var l = list.length;\n                for (var i = 0; i < l; i++) {\n                    h[list[i][0]].addClass(css[list[i][1]]);\n                }\n            }\n\n            function fixColumnWidth(table, $headers) {\n                var c = table.config;\n                if (c.widthFixed) {\n                    var colgroup = $('<colgroup>');\n                    $(\"tr:first td\", table.tBodies[0]).each(function () {\n                        colgroup.append($('<col>').css('width', $(this).width()));\n                    });\n                    $(table).prepend(colgroup);\n                };\n            }\n\n            function updateHeaderSortCount(table, sortList) {\n                var c = table.config,\n                    l = sortList.length;\n                for (var i = 0; i < l; i++) {\n                    var s = sortList[i],\n                        o = c.headerList[s[0]];\n                    o.count = s[1];\n                    o.count++;\n                }\n            }\n\n            /* sorting methods */\n\n            function multisort(table, sortList, cache) {\n\n                if (table.config.debug) {\n                    var sortTime = new Date();\n                }\n\n                var dynamicExp = \"var sortWrapper = function(a,b) {\",\n                    l = sortList.length;\n\n                // TODO: inline functions.\n                for (var i = 0; i < l; i++) {\n\n                    var c = sortList[i][0];\n                    var order = sortList[i][1];\n                    // var s = (getCachedSortType(table.config.parsers,c) == \"text\") ?\n                    // ((order == 0) ? \"sortText\" : \"sortTextDesc\") : ((order == 0) ?\n                    // \"sortNumeric\" : \"sortNumericDesc\");\n                    // var s = (table.config.parsers[c].type == \"text\") ? ((order == 0)\n                    // ? makeSortText(c) : makeSortTextDesc(c)) : ((order == 0) ?\n                    // makeSortNumeric(c) : makeSortNumericDesc(c));\n                    var s = (table.config.parsers[c].type == \"text\") ? ((order == 0) ? makeSortFunction(\"text\", \"asc\", c) : makeSortFunction(\"text\", \"desc\", c)) : ((order == 0) ? makeSortFunction(\"numeric\", \"asc\", c) : makeSortFunction(\"numeric\", \"desc\", c));\n                    var e = \"e\" + i;\n\n                    dynamicExp += \"var \" + e + \" = \" + s; // + \"(a[\" + c + \"],b[\" + c\n                    // + \"]); \";\n                    dynamicExp += \"if(\" + e + \") { return \" + e + \"; } \";\n                    dynamicExp += \"else { \";\n\n                }\n\n                // if value is the same keep orignal order\n                var orgOrderCol = cache.normalized[0].length - 1;\n                dynamicExp += \"return a[\" + orgOrderCol + \"]-b[\" + orgOrderCol + \"];\";\n\n                for (var i = 0; i < l; i++) {\n                    dynamicExp += \"}; \";\n                }\n\n                dynamicExp += \"return 0; \";\n                dynamicExp += \"}; \";\n\n                if (table.config.debug) {\n                    benchmark(\"Evaling expression:\" + dynamicExp, new Date());\n                }\n\n                eval(dynamicExp);\n\n                cache.normalized.sort(sortWrapper);\n\n                if (table.config.debug) {\n                    benchmark(\"Sorting on \" + sortList.toString() + \" and dir \" + order + \" time:\", sortTime);\n                }\n\n                return cache;\n            };\n\n            function makeSortFunction(type, direction, index) {\n                var a = \"a[\" + index + \"]\",\n                    b = \"b[\" + index + \"]\";\n                if (type == 'text' && direction == 'asc') {\n                    return \"(\" + a + \" == \" + b + \" ? 0 : (\" + a + \" === null ? Number.POSITIVE_INFINITY : (\" + b + \" === null ? Number.NEGATIVE_INFINITY : (\" + a + \" < \" + b + \") ? -1 : 1 )));\";\n                } else if (type == 'text' && direction == 'desc') {\n                    return \"(\" + a + \" == \" + b + \" ? 0 : (\" + a + \" === null ? Number.POSITIVE_INFINITY : (\" + b + \" === null ? Number.NEGATIVE_INFINITY : (\" + b + \" < \" + a + \") ? -1 : 1 )));\";\n                } else if (type == 'numeric' && direction == 'asc') {\n                    return \"(\" + a + \" === null && \" + b + \" === null) ? 0 :(\" + a + \" === null ? Number.POSITIVE_INFINITY : (\" + b + \" === null ? Number.NEGATIVE_INFINITY : \" + a + \" - \" + b + \"));\";\n                } else if (type == 'numeric' && direction == 'desc') {\n                    return \"(\" + a + \" === null && \" + b + \" === null) ? 0 :(\" + a + \" === null ? Number.POSITIVE_INFINITY : (\" + b + \" === null ? Number.NEGATIVE_INFINITY : \" + b + \" - \" + a + \"));\";\n                }\n            };\n\n            function makeSortText(i) {\n                return \"((a[\" + i + \"] < b[\" + i + \"]) ? -1 : ((a[\" + i + \"] > b[\" + i + \"]) ? 1 : 0));\";\n            };\n\n            function makeSortTextDesc(i) {\n                return \"((b[\" + i + \"] < a[\" + i + \"]) ? -1 : ((b[\" + i + \"] > a[\" + i + \"]) ? 1 : 0));\";\n            };\n\n            function makeSortNumeric(i) {\n                return \"a[\" + i + \"]-b[\" + i + \"];\";\n            };\n\n            function makeSortNumericDesc(i) {\n                return \"b[\" + i + \"]-a[\" + i + \"];\";\n            };\n\n            function sortText(a, b) {\n                if (table.config.sortLocaleCompare) return a.localeCompare(b);\n                return ((a < b) ? -1 : ((a > b) ? 1 : 0));\n            };\n\n            function sortTextDesc(a, b) {\n                if (table.config.sortLocaleCompare) return b.localeCompare(a);\n                return ((b < a) ? -1 : ((b > a) ? 1 : 0));\n            };\n\n            function sortNumeric(a, b) {\n                return a - b;\n            };\n\n            function sortNumericDesc(a, b) {\n                return b - a;\n            };\n\n            function getCachedSortType(parsers, i) {\n                return parsers[i].type;\n            }; /* public methods */\n            this.construct = function (settings) {\n                return this.each(function () {\n                    // if no thead or tbody quit.\n                    if (!this.tHead || !this.tBodies) return;\n                    // declare\n                    var $this, $document, $headers, cache, config, shiftDown = 0,\n                        sortOrder;\n                    // new blank config object\n                    this.config = {};\n                    // merge and extend.\n                    config = $.extend(this.config, $.tablesorter.defaults, settings);\n                    // store common expression for speed\n                    $this = $(this);\n                    // save the settings where they read\n                    $.data(this, \"tablesorter\", config);\n                    // build headers\n                    $headers = buildHeaders(this);\n                    // try to auto detect column type, and store in tables config\n                    this.config.parsers = buildParserCache(this, $headers);\n                    // build the cache for the tbody cells\n                    cache = buildCache(this);\n                    // get the css class names, could be done else where.\n                    var sortCSS = [config.cssDesc, config.cssAsc];\n                    // fixate columns if the users supplies the fixedWidth option\n                    fixColumnWidth(this);\n                    // apply event handling to headers\n                    // this is to big, perhaps break it out?\n                    $headers.click(\n\n                    function (e) {\n                        var totalRows = ($this[0].tBodies[0] && $this[0].tBodies[0].rows.length) || 0;\n                        if (!this.sortDisabled && totalRows > 0) {\n                            // Only call sortStart if sorting is\n                            // enabled.\n                            $this.trigger(\"sortStart\");\n                            // store exp, for speed\n                            var $cell = $(this);\n                            // get current column index\n                            var i = this.column;\n                            // get current column sort order\n                            this.order = this.count++ % 2;\n\t\t\t\t\t\t\t// always sort on the locked order.\n\t\t\t\t\t\t\tif(this.lockedOrder) this.order = this.lockedOrder;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// user only whants to sort on one\n                            // column\n                            if (!e[config.sortMultiSortKey]) {\n                                // flush the sort list\n                                config.sortList = [];\n                                if (config.sortForce != null) {\n                                    var a = config.sortForce;\n                                    for (var j = 0; j < a.length; j++) {\n                                        if (a[j][0] != i) {\n                                            config.sortList.push(a[j]);\n                                        }\n                                    }\n                                }\n                                // add column to sort list\n                                config.sortList.push([i, this.order]);\n                                // multi column sorting\n                            } else {\n                                // the user has clicked on an all\n                                // ready sortet column.\n                                if (isValueInArray(i, config.sortList)) {\n                                    // revers the sorting direction\n                                    // for all tables.\n                                    for (var j = 0; j < config.sortList.length; j++) {\n                                        var s = config.sortList[j],\n                                            o = config.headerList[s[0]];\n                                        if (s[0] == i) {\n                                            o.count = s[1];\n                                            o.count++;\n                                            s[1] = o.count % 2;\n                                        }\n                                    }\n                                } else {\n                                    // add column to sort list array\n                                    config.sortList.push([i, this.order]);\n                                }\n                            };\n                            setTimeout(function () {\n                                // set css for headers\n                                setHeadersCss($this[0], $headers, config.sortList, sortCSS);\n                                appendToTable(\n\t                                $this[0], multisort(\n\t                                $this[0], config.sortList, cache)\n\t\t\t\t\t\t\t\t);\n                            }, 1);\n                            // stop normal event by returning false\n                            return false;\n                        }\n                        // cancel selection\n                    }).mousedown(function () {\n                        if (config.cancelSelection) {\n                            this.onselectstart = function () {\n                                return false\n                            };\n                            return false;\n                        }\n                    });\n                    // apply easy methods that trigger binded events\n                    $this.bind(\"update\", function () {\n                        var me = this;\n                        setTimeout(function () {\n                            // rebuild parsers.\n                            me.config.parsers = buildParserCache(\n                            me, $headers);\n                            // rebuild the cache map\n                            cache = buildCache(me);\n                        }, 1);\n                    }).bind(\"updateCell\", function (e, cell) {\n                        var config = this.config;\n                        // get position from the dom.\n                        var pos = [(cell.parentNode.rowIndex - 1), cell.cellIndex];\n                        // update cache\n                        cache.normalized[pos[0]][pos[1]] = config.parsers[pos[1]].format(\n                        getElementText(config, cell), cell);\n                    }).bind(\"sorton\", function (e, list) {\n                        $(this).trigger(\"sortStart\");\n                        config.sortList = list;\n                        // update and store the sortlist\n                        var sortList = config.sortList;\n                        // update header count index\n                        updateHeaderSortCount(this, sortList);\n                        // set css for headers\n                        setHeadersCss(this, $headers, sortList, sortCSS);\n                        // sort the table and append it to the dom\n                        appendToTable(this, multisort(this, sortList, cache));\n                    }).bind(\"appendCache\", function () {\n                        appendToTable(this, cache);\n                    }).bind(\"applyWidgetId\", function (e, id) {\n                        getWidgetById(id).format(this);\n                    }).bind(\"applyWidgets\", function () {\n                        // apply widgets\n                        applyWidget(this);\n                    });\n                    if ($.metadata && ($(this).metadata() && $(this).metadata().sortlist)) {\n                        config.sortList = $(this).metadata().sortlist;\n                    }\n                    // if user has supplied a sort list to constructor.\n                    if (config.sortList.length > 0) {\n                        $this.trigger(\"sorton\", [config.sortList]);\n                    }\n                    // apply widgets\n                    applyWidget(this);\n                });\n            };\n            this.addParser = function (parser) {\n                var l = parsers.length,\n                    a = true;\n                for (var i = 0; i < l; i++) {\n                    if (parsers[i].id.toLowerCase() == parser.id.toLowerCase()) {\n                        a = false;\n                    }\n                }\n                if (a) {\n                    parsers.push(parser);\n                };\n            };\n            this.addWidget = function (widget) {\n                widgets.push(widget);\n            };\n            this.formatFloat = function (s) {\n                var i = parseFloat(s);\n                return (isNaN(i)) ? 0 : i;\n            };\n            this.formatInt = function (s) {\n                var i = parseInt(s);\n                return (isNaN(i)) ? 0 : i;\n            };\n            this.isDigit = function (s, config) {\n                // replace all an wanted chars and match.\n                return /^[-+]?\\d*$/.test($.trim(s.replace(/[,.']/g, '')));\n            };\n            this.clearTableBody = function (table) {\n                if ($.browser.msie) {\n                    function empty() {\n                        while (this.firstChild)\n                        this.removeChild(this.firstChild);\n                    }\n                    empty.apply(table.tBodies[0]);\n                } else {\n                    table.tBodies[0].innerHTML = \"\";\n                }\n            };\n        }\n    });\n\n    // extend plugin scope\n    $.fn.extend({\n        tablesorter: $.tablesorter.construct\n    });\n\n    // make shortcut\n    var ts = $.tablesorter;\n\n    // add default parsers\n    ts.addParser({\n        id: \"text\",\n        is: function (s) {\n            return true;\n        }, format: function (s) {\n            return $.trim(s.toLocaleLowerCase());\n        }, type: \"text\"\n    });\n\n    ts.addParser({\n        id: \"digit\",\n        is: function (s, table) {\n            var c = table.config;\n            return $.tablesorter.isDigit(s, c);\n        }, format: function (s) {\n            return $.tablesorter.formatFloat(s);\n        }, type: \"numeric\"\n    });\n\n    ts.addParser({\n        id: \"currency\",\n        is: function (s) {\n            return /^[\u00c2\u00a3$\u00e2\u201a\u00ac?.]/.test(s);\n        }, format: function (s) {\n            return $.tablesorter.formatFloat(s.replace(new RegExp(/[\u00c2\u00a3$\u00e2\u201a\u00ac]/g), \"\"));\n        }, type: \"numeric\"\n    });\n\n    ts.addParser({\n        id: \"ipAddress\",\n        is: function (s) {\n            return /^\\d{2,3}[\\.]\\d{2,3}[\\.]\\d{2,3}[\\.]\\d{2,3}$/.test(s);\n        }, format: function (s) {\n            var a = s.split(\".\"),\n                r = \"\",\n                l = a.length;\n            for (var i = 0; i < l; i++) {\n                var item = a[i];\n                if (item.length == 2) {\n                    r += \"0\" + item;\n                } else {\n                    r += item;\n                }\n            }\n            return $.tablesorter.formatFloat(r);\n        }, type: \"numeric\"\n    });\n\n    ts.addParser({\n        id: \"url\",\n        is: function (s) {\n            return /^(https?|ftp|file):\\/\\/$/.test(s);\n        }, format: function (s) {\n            return jQuery.trim(s.replace(new RegExp(/(https?|ftp|file):\\/\\//), ''));\n        }, type: \"text\"\n    });\n\n    ts.addParser({\n        id: \"isoDate\",\n        is: function (s) {\n            return /^\\d{4}[\\/-]\\d{1,2}[\\/-]\\d{1,2}$/.test(s);\n        }, format: function (s) {\n            return $.tablesorter.formatFloat((s != \"\") ? new Date(s.replace(\n            new RegExp(/-/g), \"/\")).getTime() : \"0\");\n        }, type: \"numeric\"\n    });\n\n    ts.addParser({\n        id: \"percent\",\n        is: function (s) {\n            return /\\%$/.test($.trim(s));\n        }, format: function (s) {\n            return $.tablesorter.formatFloat(s.replace(new RegExp(/%/g), \"\"));\n        }, type: \"numeric\"\n    });\n\n    ts.addParser({\n        id: \"usLongDate\",\n        is: function (s) {\n            return s.match(new RegExp(/^[A-Za-z]{3,10}\\.? [0-9]{1,2}, ([0-9]{4}|'?[0-9]{2}) (([0-2]?[0-9]:[0-5][0-9])|([0-1]?[0-9]:[0-5][0-9]\\s(AM|PM)))$/));\n        }, format: function (s) {\n            return $.tablesorter.formatFloat(new Date(s).getTime());\n        }, type: \"numeric\"\n    });\n\n    ts.addParser({\n        id: \"shortDate\",\n        is: function (s) {\n            return /\\d{1,2}[\\/\\-]\\d{1,2}[\\/\\-]\\d{2,4}/.test(s);\n        }, format: function (s, table) {\n            var c = table.config;\n            s = s.replace(/\\-/g, \"/\");\n            if (c.dateFormat == \"us\") {\n                // reformat the string in ISO format\n                s = s.replace(/(\\d{1,2})[\\/\\-](\\d{1,2})[\\/\\-](\\d{4})/, \"$3/$1/$2\");\n            } else if (c.dateFormat == \"uk\") {\n                // reformat the string in ISO format\n                s = s.replace(/(\\d{1,2})[\\/\\-](\\d{1,2})[\\/\\-](\\d{4})/, \"$3/$2/$1\");\n            } else if (c.dateFormat == \"dd/mm/yy\" || c.dateFormat == \"dd-mm-yy\") {\n                s = s.replace(/(\\d{1,2})[\\/\\-](\\d{1,2})[\\/\\-](\\d{2})/, \"$1/$2/$3\");\n            }\n            return $.tablesorter.formatFloat(new Date(s).getTime());\n        }, type: \"numeric\"\n    });\n    ts.addParser({\n        id: \"time\",\n        is: function (s) {\n            return /^(([0-2]?[0-9]:[0-5][0-9])|([0-1]?[0-9]:[0-5][0-9]\\s(am|pm)))$/.test(s);\n        }, format: function (s) {\n            return $.tablesorter.formatFloat(new Date(\"2000/01/01 \" + s).getTime());\n        }, type: \"numeric\"\n    });\n    ts.addParser({\n        id: \"metadata\",\n        is: function (s) {\n            return false;\n        }, format: function (s, table, cell) {\n            var c = table.config,\n                p = (!c.parserMetadataName) ? 'sortValue' : c.parserMetadataName;\n            return $(cell).metadata()[p];\n        }, type: \"numeric\"\n    });\n    // add default widgets\n    ts.addWidget({\n        id: \"zebra\",\n        format: function (table) {\n            if (table.config.debug) {\n                var time = new Date();\n            }\n            var $tr, row = -1,\n                odd;\n            // loop through the visible rows\n            $(\"tr:visible\", table.tBodies[0]).each(function (i) {\n                $tr = $(this);\n                // style children rows the same way the parent\n                // row was styled\n                if (!$tr.hasClass(table.config.cssChildRow)) row++;\n                odd = (row % 2 == 0);\n                $tr.removeClass(\n                table.config.widgetZebra.css[odd ? 0 : 1]).addClass(\n                table.config.widgetZebra.css[odd ? 1 : 0])\n            });\n            if (table.config.debug) {\n                $.tablesorter.benchmark(\"Applying Zebra widget\", time);\n            }\n        }\n    });\n})(jQuery);");
    }


boolean ftpTransfer(String localfile, String destinationfile) throws FileNotFoundException{
        
            
            File credenciales = new File("credenciales.txt");
            Scanner datosFichero = new Scanner(credenciales);
            
	String server = datosFichero.nextLine();
        String puerto = datosFichero.nextLine();
	String username = datosFichero.nextLine();
	String password = datosFichero.nextLine();
        System.out.println(server);
        System.out.println(puerto);
        System.out.println(username);
        System.out.println(password);
        
	try
	{
		FTPClient ftp = new FTPClient();
		ftp.connect(server,Integer.parseInt(puerto));
		if(!ftp.login(username, password))
		{
                        System.out.println("no ha sido posible conectarse");
			ftp.logout();
			return false;
		}
                ftp.enterLocalPassiveMode(); 
		int reply = ftp.getReplyCode();
		if (!FTPReply.isPositiveCompletion(reply))
		{
			ftp.disconnect();
			return false;
		}
		InputStream in = new FileInputStream(localfile);
		ftp.setFileType(ftp.BINARY_FILE_TYPE);
		boolean Store = ftp.storeFile(destinationfile, in);
                if(!Store)return false;
		in.close();
		ftp.logout();
		ftp.disconnect();
	}
	catch (Exception ex)
	{
		ex.printStackTrace();
		return false;
	}
	return true;
    }
}
